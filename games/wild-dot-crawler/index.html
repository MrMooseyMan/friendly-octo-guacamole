<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Wild-Dot Crawler</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'Fredoka', sans-serif;
            touch-action: none;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            overflow: hidden;
            user-select: none;
        }

        /* === GAME GRID === */
        .game-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            padding: 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 20px;
            position: relative;
        }

        /* === TILES === */
        .tile {
            aspect-ratio: 1;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.1s ease, box-shadow 0.15s ease;
            position: relative;
            font-size: 1.8rem;
            background: linear-gradient(145deg, var(--tile-light), var(--tile-dark));
            box-shadow: 
                0 4px 0 var(--tile-shadow),
                0 6px 12px rgba(0,0,0,0.3);
        }

        .tile:active {
            transform: translateY(2px);
            box-shadow: 
                0 2px 0 var(--tile-shadow),
                0 4px 8px rgba(0,0,0,0.3);
        }

        .tile.selected {
            transform: scale(1.15);
            z-index: 10;
            box-shadow: 
                0 0 0 3px white,
                0 0 20px 5px var(--glow-color),
                0 8px 16px rgba(0,0,0,0.4);
        }

        .tile.pulse {
            animation: tilePulse 0.3s ease;
        }

        @keyframes tilePulse {
            50% { transform: scale(1.2); }
        }

        /* Tile Colors - Vibrant and Distinct */
        .tile-attack {
            --tile-light: #ff6b6b;
            --tile-dark: #ee5a5a;
            --tile-shadow: #c44;
            --glow-color: rgba(255, 107, 107, 0.6);
        }
        .tile-heal {
            --tile-light: #51cf66;
            --tile-dark: #40c057;
            --tile-shadow: #2f9e44;
            --glow-color: rgba(81, 207, 102, 0.6);
        }
        .tile-shield {
            --tile-light: #ffd43b;
            --tile-dark: #fab005;
            --tile-shadow: #e67700;
            --glow-color: rgba(255, 212, 59, 0.6);
        }
        .tile-energy {
            --tile-light: #74c0fc;
            --tile-dark: #4dabf7;
            --tile-shadow: #1c7ed6;
            --glow-color: rgba(116, 192, 252, 0.6);
        }
        .tile-poison {
            --tile-light: #b197fc;
            --tile-dark: #9775fa;
            --tile-shadow: #7048e8;
            --glow-color: rgba(177, 151, 252, 0.6);
        }
        .tile-wild {
            --tile-light: #ffc9c9;
            --tile-dark: #ffa8a8;
            --tile-shadow: #ff6b6b;
            --glow-color: rgba(255, 255, 255, 0.6);
            background: linear-gradient(135deg, #ff6b6b, #ffd43b, #51cf66, #74c0fc, #b197fc);
            animation: rainbowShift 2s linear infinite;
        }

        @keyframes rainbowShift {
            0%, 100% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        /* === CONNECTION LINE === */
        .connection-svg {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 5;
        }

        .connection-line {
            stroke-linecap: round;
            stroke-linejoin: round;
            stroke-width: 6;
            fill: none;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        /* === CHAIN COUNTER BADGE === */
        .chain-badge {
            position: absolute;
            top: -10px;
            right: -10px;
            background: linear-gradient(135deg, #ffd43b, #fab005);
            color: #1a1a2e;
            font-weight: 700;
            font-size: 0.75rem;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            z-index: 20;
            animation: badgePop 0.2s ease;
        }

        @keyframes badgePop {
            0% { transform: scale(0); }
            70% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* === HP BARS === */
        .hp-bar-container {
            height: 24px;
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }

        .hp-bar {
            height: 100%;
            border-radius: 12px;
            transition: width 0.4s ease;
            position: relative;
        }

        .hp-bar::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(180deg, rgba(255,255,255,0.3) 0%, transparent 50%);
            border-radius: 12px;
        }

        .hp-bar-player { background: linear-gradient(90deg, #40c057, #51cf66); }
        .hp-bar-enemy { background: linear-gradient(90deg, #e03131, #ff6b6b); }
        .hp-bar-xp { background: linear-gradient(90deg, #7048e8, #b197fc); }
        .hp-bar-special { background: linear-gradient(90deg, #1c7ed6, #74c0fc); }

        .hp-text {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.75rem;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        /* === STAT CARDS === */
        .stat-card {
            background: rgba(255,255,255,0.08);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 12px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .avatar {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            flex-shrink: 0;
        }

        .avatar-player {
            background: linear-gradient(135deg, #40c057, #2f9e44);
            box-shadow: 0 4px 12px rgba(64, 192, 87, 0.3);
        }

        .avatar-enemy {
            background: linear-gradient(135deg, #e03131, #c92a2a);
            box-shadow: 0 4px 12px rgba(224, 49, 49, 0.3);
        }

        .avatar.shake {
            animation: shake 0.4s ease;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-6px) rotate(-2deg); }
            40%, 80% { transform: translateX(6px) rotate(2deg); }
        }

        /* === FLOATING TEXT === */
        .floating-text {
            position: absolute;
            font-weight: 700;
            font-size: 1.5rem;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 100;
        }

        .floating-text.large {
            font-size: 2rem;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-60px) scale(1.2); }
        }

        /* === PARTICLES === */
        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: particleFade 0.6s forwards;
        }

        @keyframes particleFade {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0); }
        }

        /* === MOVE INDICATOR === */
        .move-pip {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ffd43b;
            box-shadow: 0 0 8px rgba(255, 212, 59, 0.5);
            transition: all 0.2s ease;
        }

        .move-pip.used {
            background: rgba(255,255,255,0.2);
            box-shadow: none;
        }

        /* === COMBO DISPLAY === */
        .combo-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: 700;
            color: #ffd43b;
            text-shadow: 0 0 20px rgba(255, 212, 59, 0.8);
            pointer-events: none;
            opacity: 0;
            z-index: 50;
        }

        .combo-display.show {
            animation: comboShow 0.8s ease forwards;
        }

        @keyframes comboShow {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }

        /* === MODALS === */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            padding: 20px;
        }

        .modal-backdrop.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background: linear-gradient(145deg, #2a2a4a, #1a1a2e);
            border-radius: 24px;
            padding: 32px;
            max-width: 360px;
            width: 100%;
            text-align: center;
            border: 2px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .modal-backdrop.visible .modal-content {
            transform: scale(1);
        }

        .btn {
            padding: 14px 28px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 1.1rem;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .btn-primary {
            background: linear-gradient(135deg, #51cf66, #40c057);
            color: white;
            box-shadow: 0 4px 0 #2f9e44, 0 6px 12px rgba(0,0,0,0.3);
        }

        .btn-primary:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #2f9e44, 0 4px 8px rgba(0,0,0,0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #74c0fc, #4dabf7);
            color: white;
            box-shadow: 0 4px 0 #1c7ed6, 0 6px 12px rgba(0,0,0,0.3);
        }

        .btn-secondary:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #1c7ed6, 0 4px 8px rgba(0,0,0,0.3);
        }

        /* === UPGRADE CARDS === */
        .upgrade-card {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .upgrade-card:hover, .upgrade-card:active {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.3);
            transform: scale(1.02);
        }

        /* === TUTORIAL HINTS === */
        .hint-bubble {
            position: absolute;
            background: rgba(255, 212, 59, 0.95);
            color: #1a1a2e;
            padding: 12px 16px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.9rem;
            max-width: 200px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: hintBounce 2s infinite;
        }

        .hint-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border: 10px solid transparent;
            border-top-color: rgba(255, 212, 59, 0.95);
        }

        @keyframes hintBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        /* === SHIELD INDICATOR === */
        .shield-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            background: linear-gradient(135deg, #ffd43b, #fab005);
            color: #1a1a2e;
            font-size: 0.7rem;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 2px;
        }

        /* === STATUS EFFECTS === */
        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .status-poison {
            background: rgba(177, 151, 252, 0.3);
            color: #b197fc;
            animation: poisonPulse 1s infinite;
        }

        @keyframes poisonPulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        /* === FLOOR INDICATOR === */
        .floor-badge {
            background: linear-gradient(135deg, #7048e8, #5f3dc4);
            padding: 6px 12px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.85rem;
            color: white;
            box-shadow: 0 2px 8px rgba(112, 72, 232, 0.4);
        }

        /* Screen shake */
        .screen-shake {
            animation: screenShake 0.3s ease;
        }

        @keyframes screenShake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-4px); }
            40% { transform: translateX(4px); }
            60% { transform: translateX(-4px); }
            80% { transform: translateX(4px); }
        }

        /* Tutorial legend */
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255,255,255,0.05);
            padding: 8px 12px;
            border-radius: 10px;
        }

        .legend-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }
    </style>
</head>
<body class="text-white min-h-screen flex flex-col">

    <div id="app" class="max-w-md mx-auto w-full flex flex-col h-[100dvh] p-3">
        
        <!-- === HEADER === -->
        <div class="flex justify-between items-center mb-3">
            <div class="floor-badge">üè∞ Floor <span id="floor-num">1</span></div>
            <div class="flex items-center gap-2">
                <span class="text-sm opacity-70">Moves:</span>
                <div id="move-pips" class="flex gap-1">
                    <!-- Move pips generated by JS -->
                </div>
            </div>
        </div>

        <!-- === ENEMY CARD === -->
        <div class="stat-card mb-3">
            <div class="flex items-center gap-3">
                <div id="enemy-avatar" class="avatar avatar-enemy">üçÑ</div>
                <div class="flex-1 min-w-0">
                    <div class="flex justify-between items-baseline mb-1">
                        <h2 id="enemy-name" class="font-bold text-lg text-red-400 truncate">Gloomcap</h2>
                        <span id="enemy-status" class="flex gap-1"></span>
                    </div>
                    <div class="hp-bar-container">
                        <div id="enemy-hp-bar" class="hp-bar hp-bar-enemy" style="width: 100%"></div>
                        <span id="enemy-hp-text" class="hp-text">20 / 20</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- === GAME BOARD === -->
        <div id="board-container" class="flex-1 flex flex-col justify-center relative">
            <div id="game-grid" class="game-grid">
                <!-- Tiles generated by JS -->
            </div>
            <svg id="connection-svg" class="connection-svg" viewBox="0 0 100 100" preserveAspectRatio="none">
                <polyline id="connection-line" class="connection-line" points="" stroke="white"/>
            </svg>
            <div id="combo-display" class="combo-display"></div>
            <div id="float-container" class="absolute inset-0 pointer-events-none overflow-hidden"></div>
            <div id="particle-container" class="absolute inset-0 pointer-events-none overflow-hidden"></div>
        </div>

        <!-- === PLAYER CARD === -->
        <div class="stat-card mt-3">
            <div class="flex items-center gap-3">
                <div id="player-avatar" class="avatar avatar-player relative">üê∫
                    <div id="shield-badge" class="shield-badge hidden">üõ°Ô∏è <span id="shield-value">0</span></div>
                </div>
                <div class="flex-1 min-w-0">
                    <div class="flex justify-between items-baseline mb-1">
                        <h2 class="font-bold text-lg text-green-400">Warden</h2>
                        <span id="player-level" class="text-sm opacity-70">Lv. 1</span>
                    </div>
                    <!-- HP Bar -->
                    <div class="hp-bar-container mb-2">
                        <div id="player-hp-bar" class="hp-bar hp-bar-player" style="width: 100%"></div>
                        <span id="player-hp-text" class="hp-text">‚ù§Ô∏è 30 / 30</span>
                    </div>
                    <!-- XP & Special Bars -->
                    <div class="flex gap-2">
                        <div class="flex-1">
                            <div class="hp-bar-container h-3">
                                <div id="xp-bar" class="hp-bar hp-bar-xp" style="width: 0%"></div>
                            </div>
                            <span class="text-[10px] opacity-60">XP</span>
                        </div>
                        <div class="flex-1">
                            <div class="hp-bar-container h-3">
                                <div id="special-bar" class="hp-bar hp-bar-special" style="width: 0%"></div>
                            </div>
                            <span class="text-[10px] opacity-60">‚ö° Special</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- === START MODAL === -->
    <div id="start-modal" class="modal-backdrop visible">
        <div class="modal-content">
            <div class="text-5xl mb-4">üê∫</div>
            <h1 class="text-3xl font-bold text-green-400 mb-2">Wild-Dot Crawler</h1>
            <p class="text-gray-400 mb-6">Connect 3+ matching tiles to battle monsters!</p>
            
            <div class="grid grid-cols-2 gap-3 mb-6">
                <div class="legend-item">
                    <div class="legend-icon tile-attack">‚öîÔ∏è</div>
                    <span class="text-sm">Attack</span>
                </div>
                <div class="legend-item">
                    <div class="legend-icon tile-heal">‚ù§Ô∏è</div>
                    <span class="text-sm">Heal</span>
                </div>
                <div class="legend-item">
                    <div class="legend-icon tile-shield">üõ°Ô∏è</div>
                    <span class="text-sm">Shield</span>
                </div>
                <div class="legend-item">
                    <div class="legend-icon tile-energy">‚ö°</div>
                    <span class="text-sm">Energy</span>
                </div>
                <div class="legend-item">
                    <div class="legend-icon tile-poison">‚ò†Ô∏è</div>
                    <span class="text-sm">Poison</span>
                </div>
                <div class="legend-item">
                    <div class="legend-icon" style="background: linear-gradient(135deg, #ff6b6b, #ffd43b, #51cf66);">‚ú®</div>
                    <span class="text-sm">Wild</span>
                </div>
            </div>
            
            <p class="text-sm text-gray-500 mb-6">Longer chains = more power!<br>3 moves per turn, then the enemy strikes.</p>
            
            <button id="start-btn" class="btn btn-primary w-full">Start Adventure</button>
        </div>
    </div>

    <!-- === VICTORY MODAL === -->
    <div id="victory-modal" class="modal-backdrop">
        <div class="modal-content">
            <div class="text-5xl mb-4">üéâ</div>
            <h2 id="victory-title" class="text-3xl font-bold text-green-400 mb-2">Victory!</h2>
            <p id="victory-text" class="text-gray-400 mb-6">You defeated the Gloomcap!</p>
            <div id="victory-stats" class="text-left bg-black/20 rounded-xl p-4 mb-6">
                <div class="flex justify-between mb-2">
                    <span class="opacity-70">XP Gained</span>
                    <span id="xp-gained" class="text-purple-400 font-bold">+5</span>
                </div>
                <div class="flex justify-between">
                    <span class="opacity-70">HP Remaining</span>
                    <span id="hp-remaining" class="text-green-400 font-bold">28/30</span>
                </div>
            </div>
            <button id="next-btn" class="btn btn-primary w-full">Next Floor ‚Üí</button>
        </div>
    </div>

    <!-- === DEFEAT MODAL === -->
    <div id="defeat-modal" class="modal-backdrop">
        <div class="modal-content">
            <div class="text-5xl mb-4">üíÄ</div>
            <h2 class="text-3xl font-bold text-red-400 mb-2">Defeated...</h2>
            <p id="defeat-text" class="text-gray-400 mb-6">The dungeon claims another soul.</p>
            <div id="run-stats" class="text-left bg-black/20 rounded-xl p-4 mb-6">
                <div class="flex justify-between mb-2">
                    <span class="opacity-70">Floors Cleared</span>
                    <span id="floors-cleared" class="text-purple-400 font-bold">3</span>
                </div>
                <div class="flex justify-between mb-2">
                    <span class="opacity-70">Enemies Slain</span>
                    <span id="enemies-slain" class="text-red-400 font-bold">3</span>
                </div>
                <div class="flex justify-between">
                    <span class="opacity-70">Total Damage</span>
                    <span id="total-damage" class="text-orange-400 font-bold">156</span>
                </div>
            </div>
            <button id="retry-btn" class="btn btn-secondary w-full">Try Again</button>
        </div>
    </div>

    <!-- === LEVEL UP MODAL === -->
    <div id="levelup-modal" class="modal-backdrop">
        <div class="modal-content">
            <div class="text-5xl mb-4">‚¨ÜÔ∏è</div>
            <h2 class="text-3xl font-bold text-yellow-400 mb-2">Level Up!</h2>
            <p class="text-gray-400 mb-6">Choose an upgrade:</p>
            <div class="space-y-3">
                <div class="upgrade-card" onclick="game.applyUpgrade('hp')">
                    <div class="flex items-center gap-3">
                        <span class="text-2xl">‚ù§Ô∏è</span>
                        <div class="text-left">
                            <div class="font-bold text-green-400">Vigor</div>
                            <div class="text-sm opacity-70">+10 Max HP</div>
                        </div>
                    </div>
                </div>
                <div class="upgrade-card" onclick="game.applyUpgrade('attack')">
                    <div class="flex items-center gap-3">
                        <span class="text-2xl">‚öîÔ∏è</span>
                        <div class="text-left">
                            <div class="font-bold text-red-400">Strength</div>
                            <div class="text-sm opacity-70">+2 Base Damage</div>
                        </div>
                    </div>
                </div>
                <div class="upgrade-card" onclick="game.applyUpgrade('special')">
                    <div class="flex items-center gap-3">
                        <span class="text-2xl">‚ö°</span>
                        <div class="text-left">
                            <div class="font-bold text-blue-400">Attunement</div>
                            <div class="text-sm opacity-70">-2 Special Cost</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    // ============================================
    // WILD-DOT CRAWLER - GAME ENGINE
    // ============================================

    const game = {
        // === CONSTANTS ===
        GRID_SIZE: 6,
        MOVES_PER_TURN: 3,
        TILE_TYPES: ['attack', 'heal', 'shield', 'energy', 'poison'],
        TILE_ICONS: {
            attack: '‚öîÔ∏è',
            heal: '‚ù§Ô∏è',
            shield: 'üõ°Ô∏è',
            energy: '‚ö°',
            poison: '‚ò†Ô∏è',
            wild: '‚ú®'
        },
        TILE_WEIGHTS: {
            attack: 25,
            heal: 20,
            shield: 20,
            energy: 20,
            poison: 15
        },
        
        ENEMIES: [
            { id: 'gloomcap', name: 'Gloomcap', emoji: 'üçÑ', hp: 20, atk: 4, xp: 5 },
            { id: 'slime', name: 'Shadow Slime', emoji: 'ü´ß', hp: 25, atk: 5, xp: 7 },
            { id: 'bat', name: 'Cave Bat', emoji: 'ü¶á', hp: 18, atk: 6, xp: 6 },
            { id: 'spider', name: 'Web Spinner', emoji: 'üï∑Ô∏è', hp: 30, atk: 5, xp: 8 },
            { id: 'golem', name: 'Stone Golem', emoji: 'ü™®', hp: 45, atk: 7, xp: 12 },
            { id: 'wraith', name: 'Grove Wraith', emoji: 'üëª', hp: 35, atk: 8, xp: 10 },
            { id: 'dragon', name: 'Elder Drake', emoji: 'üêâ', hp: 60, atk: 10, xp: 20 },
        ],

        // === STATE ===
        grid: [],
        selected: [],
        isDragging: false,
        isAnimating: false,
        gameActive: false,
        
        player: {
            hp: 30, maxHp: 30,
            shield: 0,
            special: 0, maxSpecial: 10,
            level: 1, xp: 0, nextXp: 10,
            bonusDamage: 0, bonusHeal: 0
        },
        
        enemy: null,
        floor: 1,
        movesLeft: 3,
        combo: 0,
        
        // Stats tracking
        stats: { floorsCleared: 0, enemiesSlain: 0, totalDamage: 0 },
        
        // Poison effect on enemy
        poison: { active: false, damage: 0, turns: 0 },

        // === AUDIO ===
        audioReady: false,
        synths: {},

        initAudio() {
            if (this.audioReady) return;
            
            this.synths.select = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: { attack: 0.005, decay: 0.08, sustain: 0, release: 0.05 }
            }).toDestination();
            
            this.synths.connect = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.01, decay: 0.12, sustain: 0, release: 0.08 }
            }).toDestination();
            
            this.synths.attack = new Tone.NoiseSynth({
                noise: { type: 'white' },
                envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.05 }
            }).toDestination();
            
            this.synths.heal = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.05, decay: 0.2, sustain: 0.1, release: 0.1 }
            }).toDestination();
            
            this.synths.power = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'sine' },
                envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 }
            }).toDestination();
            
            Tone.start();
            this.audioReady = true;
        },

        playSound(type, value = 0) {
            if (!this.audioReady) return;
            try {
                const notes = ['C5', 'D5', 'E5', 'G5', 'A5', 'C6', 'D6', 'E6'];
                switch (type) {
                    case 'select':
                        this.synths.select.triggerAttackRelease('C5', '32n');
                        break;
                    case 'connect':
                        this.synths.connect.triggerAttackRelease(notes[Math.min(value, notes.length - 1)], '16n');
                        break;
                    case 'deselect':
                        this.synths.select.triggerAttackRelease('A4', '32n');
                        break;
                    case 'attack':
                        this.synths.attack.triggerAttackRelease('16n');
                        break;
                    case 'heal':
                        this.synths.heal.triggerAttackRelease('E4', '8n');
                        setTimeout(() => this.synths.heal.triggerAttackRelease('G4', '8n'), 80);
                        break;
                    case 'shield':
                        this.synths.heal.triggerAttackRelease('D3', '8n');
                        break;
                    case 'special':
                        this.synths.power.triggerAttackRelease(['C5', 'E5', 'G5'], '8n');
                        break;
                    case 'combo':
                        this.synths.power.triggerAttackRelease(['E5', 'G5', 'B5'], '8n');
                        break;
                    case 'victory':
                        setTimeout(() => this.synths.power.triggerAttackRelease(['C5', 'E5'], '4n'), 0);
                        setTimeout(() => this.synths.power.triggerAttackRelease(['E5', 'G5'], '4n'), 200);
                        setTimeout(() => this.synths.power.triggerAttackRelease(['G5', 'C6'], '2n'), 400);
                        break;
                    case 'levelup':
                        setTimeout(() => this.synths.power.triggerAttackRelease(['C4', 'E4', 'G4'], '4n'), 0);
                        setTimeout(() => this.synths.power.triggerAttackRelease(['D4', 'F#4', 'A4'], '4n'), 300);
                        setTimeout(() => this.synths.power.triggerAttackRelease(['E4', 'G4', 'B4', 'D5'], '2n'), 600);
                        break;
                }
            } catch (e) {
                console.warn('Audio error:', e);
            }
        },

        // === DOM REFS ===
        elements: {},
        
        cacheElements() {
            this.elements = {
                grid: document.getElementById('game-grid'),
                boardContainer: document.getElementById('board-container'),
                connectionLine: document.getElementById('connection-line'),
                movePips: document.getElementById('move-pips'),
                floorNum: document.getElementById('floor-num'),
                comboDisplay: document.getElementById('combo-display'),
                floatContainer: document.getElementById('float-container'),
                particleContainer: document.getElementById('particle-container'),
                
                playerHpBar: document.getElementById('player-hp-bar'),
                playerHpText: document.getElementById('player-hp-text'),
                playerLevel: document.getElementById('player-level'),
                playerAvatar: document.getElementById('player-avatar'),
                shieldBadge: document.getElementById('shield-badge'),
                shieldValue: document.getElementById('shield-value'),
                xpBar: document.getElementById('xp-bar'),
                specialBar: document.getElementById('special-bar'),
                
                enemyAvatar: document.getElementById('enemy-avatar'),
                enemyName: document.getElementById('enemy-name'),
                enemyHpBar: document.getElementById('enemy-hp-bar'),
                enemyHpText: document.getElementById('enemy-hp-text'),
                enemyStatus: document.getElementById('enemy-status'),
                
                startModal: document.getElementById('start-modal'),
                victoryModal: document.getElementById('victory-modal'),
                defeatModal: document.getElementById('defeat-modal'),
                levelupModal: document.getElementById('levelup-modal'),
                
                victoryText: document.getElementById('victory-text'),
                xpGained: document.getElementById('xp-gained'),
                hpRemaining: document.getElementById('hp-remaining'),
                floorsCleared: document.getElementById('floors-cleared'),
                enemiesSlain: document.getElementById('enemies-slain'),
                totalDamage: document.getElementById('total-damage'),
            };
        },

        // === INITIALIZATION ===
        init() {
            this.cacheElements();
            
            document.getElementById('start-btn').onclick = () => this.startGame();
            document.getElementById('next-btn').onclick = () => this.nextFloor();
            document.getElementById('retry-btn').onclick = () => location.reload();
            
            document.addEventListener('contextmenu', e => e.preventDefault());
        },

        startGame() {
            this.initAudio();
            this.elements.startModal.classList.remove('visible');
            
            this.player = {
                hp: 30, maxHp: 30,
                shield: 0,
                special: 0, maxSpecial: 10,
                level: 1, xp: 0, nextXp: 10,
                bonusDamage: 0, bonusHeal: 0
            };
            this.floor = 1;
            this.stats = { floorsCleared: 0, enemiesSlain: 0, totalDamage: 0 };
            
            this.spawnEnemy();
            this.generateGrid();
            this.gameActive = true;
            this.updateUI();
        },

        // === GRID GENERATION ===
        generateGrid() {
            this.grid = [];
            for (let r = 0; r < this.GRID_SIZE; r++) {
                const row = [];
                for (let c = 0; c < this.GRID_SIZE; c++) {
                    row.push(this.getRandomTile());
                }
                this.grid.push(row);
            }
            // Maybe spawn a wild tile
            if (Math.random() < 0.1) {
                const r = Math.floor(Math.random() * this.GRID_SIZE);
                const c = Math.floor(Math.random() * this.GRID_SIZE);
                this.grid[r][c] = 'wild';
            }
            this.renderGrid();
        },

        getRandomTile() {
            const totalWeight = Object.values(this.TILE_WEIGHTS).reduce((a, b) => a + b, 0);
            let rand = Math.random() * totalWeight;
            for (const [type, weight] of Object.entries(this.TILE_WEIGHTS)) {
                rand -= weight;
                if (rand <= 0) return type;
            }
            return 'attack';
        },

        renderGrid() {
            this.elements.grid.innerHTML = '';
            
            for (let r = 0; r < this.GRID_SIZE; r++) {
                for (let c = 0; c < this.GRID_SIZE; c++) {
                    const type = this.grid[r][c];
                    const tile = document.createElement('div');
                    tile.className = `tile tile-${type}`;
                    tile.dataset.r = r;
                    tile.dataset.c = c;
                    tile.textContent = this.TILE_ICONS[type] || '?';
                    
                    // Check if selected
                    const selIdx = this.selected.findIndex(s => s.r === r && s.c === c);
                    if (selIdx !== -1) {
                        tile.classList.add('selected');
                        // Add chain badge on last tile
                        if (selIdx === this.selected.length - 1 && this.selected.length >= 3) {
                            const badge = document.createElement('div');
                            badge.className = 'chain-badge';
                            badge.textContent = this.selected.length;
                            tile.appendChild(badge);
                        }
                    }
                    
                    tile.addEventListener('pointerdown', (e) => this.handlePointerDown(e));
                    tile.addEventListener('pointerenter', (e) => this.handlePointerEnter(e));
                    
                    this.elements.grid.appendChild(tile);
                }
            }
            
            this.updateConnectionLine();
        },

        updateConnectionLine() {
            if (this.selected.length < 2) {
                this.elements.connectionLine.setAttribute('points', '');
                return;
            }
            
            const first = this.selected[0];
            const type = this.grid[first.r][first.c];
            const colors = {
                attack: '#ff6b6b',
                heal: '#51cf66',
                shield: '#ffd43b',
                energy: '#74c0fc',
                poison: '#b197fc',
                wild: '#ffffff'
            };
            
            const cellSize = 100 / this.GRID_SIZE;
            const points = this.selected.map(({r, c}) => {
                const x = (c + 0.5) * cellSize;
                const y = (r + 0.5) * cellSize;
                return `${x},${y}`;
            }).join(' ');
            
            this.elements.connectionLine.setAttribute('points', points);
            this.elements.connectionLine.setAttribute('stroke', colors[type] || '#fff');
        },

        // === INPUT HANDLING ===
        handlePointerDown(e) {
            if (!this.gameActive || this.isAnimating || this.movesLeft <= 0) return;
            
            const r = parseInt(e.currentTarget.dataset.r);
            const c = parseInt(e.currentTarget.dataset.c);
            
            this.isDragging = true;
            this.selected = [{ r, c }];
            this.playSound('select');
            this.renderGrid();
            
            document.addEventListener('pointerup', () => this.handlePointerUp(), { once: true });
        },

        handlePointerEnter(e) {
            if (!this.isDragging || this.isAnimating) return;
            
            const r = parseInt(e.currentTarget.dataset.r);
            const c = parseInt(e.currentTarget.dataset.c);
            const last = this.selected[this.selected.length - 1];
            
            // Check adjacency (including diagonals)
            const isAdjacent = Math.abs(r - last.r) <= 1 && Math.abs(c - last.c) <= 1;
            
            // Check if same type or wild
            const lastType = this.grid[last.r][last.c];
            const thisType = this.grid[r][c];
            const canConnect = thisType === lastType || thisType === 'wild' || lastType === 'wild';
            
            // Check if already selected
            const existingIdx = this.selected.findIndex(s => s.r === r && s.c === c);
            
            if (existingIdx !== -1) {
                // Backtracking
                if (existingIdx === this.selected.length - 2) {
                    this.selected.pop();
                    this.playSound('deselect');
                    this.renderGrid();
                }
                return;
            }
            
            if (isAdjacent && canConnect) {
                this.selected.push({ r, c });
                this.playSound('connect', this.selected.length - 1);
                this.renderGrid();
            }
        },

        handlePointerUp() {
            this.isDragging = false;
            
            if (this.selected.length >= 3) {
                this.processMatch();
            } else {
                this.selected = [];
                this.renderGrid();
            }
        },

        // === MATCH PROCESSING ===
        async processMatch() {
            this.isAnimating = true;
            
            const firstSel = this.selected[0];
            let type = this.grid[firstSel.r][firstSel.c];
            
            // If first is wild, find the actual type
            if (type === 'wild') {
                for (const sel of this.selected) {
                    const t = this.grid[sel.r][sel.c];
                    if (t !== 'wild') {
                        type = t;
                        break;
                    }
                }
            }
            
            const count = this.selected.length;
            this.combo++;
            
            // Calculate power with length bonus
            const lengthBonus = count >= 6 ? 2.0 : count >= 5 ? 1.5 : count >= 4 ? 1.2 : 1.0;
            const comboBonus = 1 + (this.combo - 1) * 0.2;
            const power = Math.floor(count * lengthBonus * comboBonus);
            
            // Show combo if > 1
            if (this.combo > 1) {
                this.showCombo(this.combo);
                this.playSound('combo');
            }
            
            // Apply effect
            this.applyEffect(type, power);
            
            // Spawn particles
            this.spawnParticles(type);
            
            // Clear tiles
            for (const { r, c } of this.selected) {
                this.grid[r][c] = null;
            }
            
            this.elements.connectionLine.setAttribute('points', '');
            this.selected = [];
            this.movesLeft--;
            
            this.renderGrid();
            this.updateUI();
            
            await this.sleep(200);
            
            // Drop tiles
            await this.dropTiles();
            
            // Check win
            if (this.enemy.hp <= 0) {
                await this.handleVictory();
                return;
            }
            
            // Check end of turn
            if (this.movesLeft <= 0) {
                await this.enemyTurn();
            }
            
            this.isAnimating = false;
        },

        applyEffect(type, power) {
            let text = '';
            let textType = 'neutral';
            
            switch (type) {
                case 'attack':
                    const dmg = power + this.player.bonusDamage;
                    this.enemy.hp = Math.max(0, this.enemy.hp - dmg);
                    this.stats.totalDamage += dmg;
                    this.playSound('attack');
                    this.shakeElement(this.elements.enemyAvatar);
                    this.screenShake();
                    text = `-${dmg}`;
                    textType = 'damage';
                    break;
                    
                case 'heal':
                    const heal = Math.floor(power * 1.5) + this.player.bonusHeal;
                    const actualHeal = Math.min(heal, this.player.maxHp - this.player.hp);
                    this.player.hp = Math.min(this.player.maxHp, this.player.hp + heal);
                    this.playSound('heal');
                    text = `+${actualHeal}`;
                    textType = 'heal';
                    break;
                    
                case 'shield':
                    const shield = Math.floor(power * 1.2);
                    this.player.shield += shield;
                    this.playSound('shield');
                    text = `+${shield} üõ°Ô∏è`;
                    textType = 'shield';
                    break;
                    
                case 'energy':
                    const energy = Math.floor(power * 1.2);
                    this.player.special = Math.min(this.player.maxSpecial * 2, this.player.special + energy);
                    this.playSound('special');
                    text = `+${energy} ‚ö°`;
                    textType = 'special';
                    break;
                    
                case 'poison':
                    const poisonDmg = Math.floor(power * 0.7);
                    const poisonDoT = Math.max(1, Math.floor(power * 0.4));
                    this.enemy.hp = Math.max(0, this.enemy.hp - poisonDmg);
                    this.stats.totalDamage += poisonDmg;
                    this.poison.active = true;
                    this.poison.damage += poisonDoT;
                    this.poison.turns = 3;
                    this.playSound('attack');
                    this.shakeElement(this.elements.enemyAvatar);
                    text = `-${poisonDmg} ‚ò†Ô∏è`;
                    textType = 'poison';
                    break;
                    
                case 'wild':
                    // Wild matches boost everything a little
                    const wildBuff = Math.floor(power * 0.5);
                    this.player.shield += wildBuff;
                    this.player.special += wildBuff;
                    this.enemy.hp = Math.max(0, this.enemy.hp - wildBuff);
                    this.stats.totalDamage += wildBuff;
                    this.playSound('special');
                    this.shakeElement(this.elements.enemyAvatar);
                    text = `‚ú® All +${wildBuff}`;
                    textType = 'special';
                    break;
            }
            
            this.showFloatingText(text, textType);
            this.updateUI();
            
            // Check special trigger
            if (this.player.special >= this.player.maxSpecial) {
                this.triggerSpecial();
            }
        },

        async triggerSpecial() {
            this.player.special -= this.player.maxSpecial;
            
            const damage = 15 + this.player.level * 3 + this.player.bonusDamage;
            this.enemy.hp = Math.max(0, this.enemy.hp - damage);
            this.stats.totalDamage += damage;
            
            this.playSound('special');
            this.screenShake();
            this.shakeElement(this.elements.enemyAvatar);
            
            setTimeout(() => {
                this.showFloatingText(`‚ö° SURGE! -${damage}`, 'special', true);
            }, 200);
            
            this.updateUI();
        },

        async dropTiles() {
            // Drop existing tiles down
            for (let c = 0; c < this.GRID_SIZE; c++) {
                let writeIdx = this.GRID_SIZE - 1;
                for (let r = this.GRID_SIZE - 1; r >= 0; r--) {
                    if (this.grid[r][c] !== null) {
                        this.grid[writeIdx][c] = this.grid[r][c];
                        if (writeIdx !== r) this.grid[r][c] = null;
                        writeIdx--;
                    }
                }
                // Fill from top
                while (writeIdx >= 0) {
                    this.grid[writeIdx][c] = this.getRandomTile();
                    writeIdx--;
                }
            }
            
            // Small chance for wild tile
            if (Math.random() < 0.05) {
                const r = Math.floor(Math.random() * 2);
                const c = Math.floor(Math.random() * this.GRID_SIZE);
                this.grid[r][c] = 'wild';
            }
            
            this.renderGrid();
            await this.sleep(150);
        },

        // === ENEMY ===
        spawnEnemy() {
            const idx = Math.min(this.floor - 1, this.ENEMIES.length - 1);
            const template = this.ENEMIES[idx];
            const scaling = Math.floor((this.floor - 1) / this.ENEMIES.length);
            
            this.enemy = {
                ...template,
                hp: template.hp + scaling * 15,
                maxHp: template.hp + scaling * 15,
                atk: template.atk + scaling * 2,
            };
            
            this.movesLeft = this.MOVES_PER_TURN;
            this.combo = 0;
            this.poison = { active: false, damage: 0, turns: 0 };
        },

        async enemyTurn() {
            this.gameActive = false;
            this.combo = 0;
            
            await this.sleep(400);
            
            // Apply poison first
            if (this.poison.active && this.poison.turns > 0) {
                const dmg = this.poison.damage;
                this.enemy.hp = Math.max(0, this.enemy.hp - dmg);
                this.stats.totalDamage += dmg;
                this.poison.turns--;
                
                if (this.poison.turns <= 0) {
                    this.poison.active = false;
                    this.poison.damage = 0;
                }
                
                this.shakeElement(this.elements.enemyAvatar);
                this.showFloatingText(`-${dmg} ‚ò†Ô∏è`, 'poison');
                this.updateUI();
                
                await this.sleep(500);
                
                if (this.enemy.hp <= 0) {
                    await this.handleVictory();
                    return;
                }
            }
            
            await this.sleep(400);
            
            // Enemy attacks
            let damage = this.enemy.atk;
            
            // Shield absorbs damage
            if (this.player.shield > 0) {
                const blocked = Math.min(this.player.shield, damage);
                this.player.shield -= blocked;
                damage -= blocked;
                
                if (blocked > 0) {
                    this.showFloatingText(`Blocked ${blocked}!`, 'shield');
                    await this.sleep(300);
                }
            }
            
            if (damage > 0) {
                this.player.hp = Math.max(0, this.player.hp - damage);
                this.playSound('attack');
                this.shakeElement(this.elements.playerAvatar);
                this.screenShake();
                this.showFloatingText(`-${damage}`, 'damage');
            }
            
            this.updateUI();
            
            if (this.player.hp <= 0) {
                await this.handleDefeat();
                return;
            }
            
            // New turn
            this.movesLeft = this.MOVES_PER_TURN;
            this.gameActive = true;
            this.updateUI();
        },

        // === VICTORY / DEFEAT ===
        async handleVictory() {
            this.gameActive = false;
            this.playSound('victory');
            
            const xpGained = this.enemy.xp;
            this.player.xp += xpGained;
            this.stats.enemiesSlain++;
            this.stats.floorsCleared++;
            
            // Check level up
            if (this.player.xp >= this.player.nextXp) {
                await this.sleep(500);
                this.showLevelUp();
                return;
            }
            
            this.elements.victoryText.textContent = `You defeated the ${this.enemy.name}!`;
            this.elements.xpGained.textContent = `+${xpGained}`;
            this.elements.hpRemaining.textContent = `${this.player.hp}/${this.player.maxHp}`;
            
            await this.sleep(500);
            this.elements.victoryModal.classList.add('visible');
        },

        async handleDefeat() {
            this.gameActive = false;
            
            this.elements.floorsCleared.textContent = this.stats.floorsCleared;
            this.elements.enemiesSlain.textContent = this.stats.enemiesSlain;
            this.elements.totalDamage.textContent = this.stats.totalDamage;
            
            await this.sleep(500);
            this.elements.defeatModal.classList.add('visible');
        },

        showLevelUp() {
            this.playSound('levelup');
            this.elements.levelupModal.classList.add('visible');
        },

        applyUpgrade(type) {
            switch (type) {
                case 'hp':
                    this.player.maxHp += 10;
                    this.player.hp += 10;
                    break;
                case 'attack':
                    this.player.bonusDamage += 2;
                    break;
                case 'special':
                    this.player.maxSpecial = Math.max(4, this.player.maxSpecial - 2);
                    break;
            }
            
            this.player.xp -= this.player.nextXp;
            this.player.nextXp = Math.floor(this.player.nextXp * 1.5);
            this.player.level++;
            
            this.elements.levelupModal.classList.remove('visible');
            
            // Now show victory modal
            this.elements.xpGained.textContent = `+${this.enemy.xp}`;
            this.elements.hpRemaining.textContent = `${this.player.hp}/${this.player.maxHp}`;
            this.elements.victoryText.textContent = `You defeated the ${this.enemy.name}!`;
            
            setTimeout(() => {
                this.elements.victoryModal.classList.add('visible');
            }, 300);
        },

        nextFloor() {
            this.elements.victoryModal.classList.remove('visible');
            this.floor++;
            this.spawnEnemy();
            this.generateGrid();
            this.gameActive = true;
            this.updateUI();
        },

        // === UI UPDATES ===
        updateUI() {
            const p = this.player;
            const e = this.enemy;
            
            // Floor
            this.elements.floorNum.textContent = this.floor;
            
            // Move pips
            this.elements.movePips.innerHTML = '';
            for (let i = 0; i < this.MOVES_PER_TURN; i++) {
                const pip = document.createElement('div');
                pip.className = 'move-pip' + (i >= this.movesLeft ? ' used' : '');
                this.elements.movePips.appendChild(pip);
            }
            
            // Player
            this.elements.playerHpBar.style.width = `${(p.hp / p.maxHp) * 100}%`;
            this.elements.playerHpText.textContent = `‚ù§Ô∏è ${p.hp} / ${p.maxHp}`;
            this.elements.playerLevel.textContent = `Lv. ${p.level}`;
            this.elements.xpBar.style.width = `${(p.xp / p.nextXp) * 100}%`;
            this.elements.specialBar.style.width = `${Math.min(100, (p.special / p.maxSpecial) * 100)}%`;
            
            // Shield
            if (p.shield > 0) {
                this.elements.shieldBadge.classList.remove('hidden');
                this.elements.shieldValue.textContent = p.shield;
            } else {
                this.elements.shieldBadge.classList.add('hidden');
            }
            
            // Enemy
            if (e) {
                this.elements.enemyAvatar.textContent = e.emoji;
                this.elements.enemyName.textContent = e.name;
                this.elements.enemyHpBar.style.width = `${(e.hp / e.maxHp) * 100}%`;
                this.elements.enemyHpText.textContent = `${e.hp} / ${e.maxHp}`;
                
                // Poison status
                if (this.poison.active && this.poison.turns > 0) {
                    this.elements.enemyStatus.innerHTML = `<span class="status-badge status-poison">‚ò†Ô∏è ${this.poison.damage}/turn (${this.poison.turns})</span>`;
                } else {
                    this.elements.enemyStatus.innerHTML = '';
                }
            }
        },

        // === VISUAL EFFECTS ===
        showFloatingText(text, type, large = false) {
            const el = document.createElement('div');
            el.className = 'floating-text' + (large ? ' large' : '');
            el.textContent = text;
            
            const colors = {
                damage: '#ff6b6b',
                heal: '#51cf66',
                shield: '#ffd43b',
                special: '#74c0fc',
                poison: '#b197fc',
                neutral: '#ffffff'
            };
            el.style.color = colors[type] || colors.neutral;
            
            const x = 30 + Math.random() * 40;
            const y = 30 + Math.random() * 40;
            el.style.left = `${x}%`;
            el.style.top = `${y}%`;
            
            this.elements.floatContainer.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        },

        showCombo(count) {
            const display = this.elements.comboDisplay;
            display.textContent = `${count}x COMBO!`;
            display.classList.remove('show');
            void display.offsetWidth; // Trigger reflow
            display.classList.add('show');
        },

        spawnParticles(type) {
            const colors = {
                attack: '#ff6b6b',
                heal: '#51cf66',
                shield: '#ffd43b',
                energy: '#74c0fc',
                poison: '#b197fc',
                wild: '#ffffff'
            };
            const color = colors[type] || '#fff';
            
            for (let i = 0; i < 12; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.background = color;
                particle.style.width = (6 + Math.random() * 8) + 'px';
                particle.style.height = particle.style.width;
                particle.style.left = (30 + Math.random() * 40) + '%';
                particle.style.top = (30 + Math.random() * 40) + '%';
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 50;
                const tx = Math.cos(angle) * distance;
                const ty = Math.sin(angle) * distance;
                
                particle.animate([
                    { transform: 'translate(0, 0) scale(1)', opacity: 1 },
                    { transform: `translate(${tx}px, ${ty}px) scale(0)`, opacity: 0 }
                ], { duration: 600, easing: 'ease-out' });
                
                this.elements.particleContainer.appendChild(particle);
                setTimeout(() => particle.remove(), 600);
            }
        },

        shakeElement(el) {
            el.classList.add('shake');
            setTimeout(() => el.classList.remove('shake'), 400);
        },

        screenShake() {
            this.elements.boardContainer.classList.add('screen-shake');
            setTimeout(() => this.elements.boardContainer.classList.remove('screen-shake'), 300);
        },

        // === UTILITIES ===
        sleep(ms) {
            return new Promise(r => setTimeout(r, ms));
        }
    };

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => game.init());
    </script>
</body>
</html>
